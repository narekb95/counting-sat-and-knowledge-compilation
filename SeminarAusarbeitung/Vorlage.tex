% Vorlage für Seminar-Ausarbeitungen
%
% Dateiname: Vorlage.tex
% zuletzt geändert: 11. Februar 2016
% Autorin: Nicole Schweikardt

% Definition der Dokument-Klasse, in diesem Falle die Klasse SeminarAusarbeitung,
% die in der Datei SeminarAusarbeitung.cls bereitgestellt wird
\documentclass{SeminarAusarbeitung}

\title{Knowledge compilation and \#SAT}
\author{Narek Bojikian}
\seminar{Aktuelle Themen der theoretischen Informatik}
\semester{Wintersemester 2019/~2020}
\leitung{Prof.\ Dr.\ Christoph Berkholz} 
\institut{Institut für Informatik}
\universitaet{Humboldt-Universität zu Berlin}

\usepackage{bbold}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{tikz}

\usetikzlibrary{topaths,calc}

\begin{document}

\maketitle

{{\color{red}\Huge todo} \color{blue}\Large 
\begin{itemize}
\item A paper written by? authored from? from? 
\item fill [todo] and check \\cite tags
\item add reference to the paper in abstract
\end{itemize}
}
\begin{abstract}
	In this report, we summarize the paper "Understanding the complexity of
	\#SAT using knowledge compilation" by Florent Capeli, 2018. We focus on
	the points presented and discussed during the seminar on 08.01.2020.
	More specifically, the paper is divided in to two parts. In the first of
	which, the author designs an efficient algorithm for the given problem
	using DPLL method, used to implement a practical solver for the \#SAT
	problem. In the second part, the author generalizes another schema, that
	had been used before to prove efficient algorithms for this problem on
	specific classes of formulas. He proves that this schema has a
	super-polynomial running time on this specific class of formulas.  We
	concentrate on the efficient algorithm presented in the paper and
	highlight its steps, and we suffice to list the results that yield a
	lower-bound on the running time of the other method.
\end{abstract}

\section{Background}
The \#SAT problem is the problem of finding the number of satisfying assignments
of a given formula.  The very related SAT problem, which targets the question
whether a given formula admits a satisfying assignment, has been one of the most
studied problems in theoretical computer science. The interest in this problem
increased drastically since the appearance of Cook-Levin theorem \cite{} [todo],
which states that SAT is an NP-hard problem.  This theorem has been prominent in
theoretical computer science ever since. One of the results of the theorem is
that a problem is NP-hard if it admits a polynomial reduction to SAT. This
inspired a follow up by Karp \cite{} [todo] and many other results that
initiated a new era of theoretical computer science. The interest in SAT and
NP-completeness however, influenced an increasing interest in a very related
complexity class, namely the \#P which includes all the functions that count the
number of certificates for polynomial balanced languages.  Clearly problems that
are complete for \#P are at least as hard as NP-complete problems, since NP is
equivalent to the existential class of P, namely $\exists$P. Interestingly,
\#SAT problem is complete for \#SAT.  Again this resulted in an increasing
interest in the \#SAT problem. Among others, counting the perfect matchings in a
graph and computing the permanent of a matrix are also complete for the \#P
class and hence, any breakthrough in solving \#SAT will have a great impact on
the solvablility of these problems.

On the other hand, different approaches have been developed to tackle this
problem. On one side, there has been an interest in practical solvers, ones that
might not yield efficient bounds in theory, but have proven efficient in
practice. An example of which, is the DPLL solver. The idea of the solver is to
simplify the formula and to branch over variables to result in simpler formulas.
Careful cashing and the choice of variables are essential for an efficient
solver. However, for different classes of formulas, a special boolean formula of
each of these classes can be designed in way that this method can be quite
inefficient on these formulas. Therefore, this method was merely used for
practical solvers and had not been used in theory to prove efficient
upper-bounds on \#SAT.  On the other hand, some approaches have been designed to
tackle this problem from the theoretical perspective. By restricting the classes
of formulas, some methods have proven efficient for solving \#SAT on these
classes. For example in .. \cite{} [todo] .... However, the main goal of the
presented paper is to show that the practical method can be more efficient even
in theory for some specific classes of formulas and thereby we should not
underestimate the method when approaching new classes of formulas. More
specifically, the author shows in this paper, that using the techniques from
DPLL, \#SAT on $\beta$-acyclic formulas can be solved in Polynomial time,
meanwhile the standard theoretical technique has a super-polynomial lower-bound
on its running time.

A bit deeper into details, the theoretical techniques start by building a
simpler formula equivalent to the input with useful properties and then solve
the problem on the resulting formula using dynamic programming. The paper shows
a subset of $\beta$-acyclic formulas such that any equivalent formula with that
specific set of properties has super-polynomial size and hence the method can
not be run in polynomial time. In contrast, the efficient method will also make
use of dynamic programming but it starts with finding an efficient order of the
vertices.

We start the report with a set of definitions that introduces all the concepts,
the structures and the terms needed to complete the report. Similar to the
presentation, we follow that with a brief introduction to $\beta$-acyclic graphs
and list some of their properties that will show useful later in this report. In
the third section, we focus on the efficient algorithm for \#SAT in
$\beta$-acyclic graphs, where we list the main lemmas that yield the {\it main}
(own opinion) result of the paper with brief sketches of the proofs. The forth
section is a list of results that yield the lower bounds on the theoretical
technique with according references. We conclude with a brief summary of the
results and the key takeaway of the paper.

\section{Preliminaries and notation}
\subsection{Boolean formulas and assignments}
We begin this section with formal definitions of the problems introduced
previously, and we introduce the normal forms we will encounter in this report
along with the definition of a partial assignment.
\begin{itemize}
	\item A Boolean formula $\varphi$ is a Boolean combination of a given
		set of variables $\operatorname{Var}(\varphi) := x_1, \dots, x_n$ and
		constants $\mathbb{0}$ and $\mathbb{1}$.
	\item An assignment $\tau$ of $\varphi$ is a Boolean function that assigns to
		each variable of the formula a Boolean value
		$$\tau:\operatorname{Var}(\varphi) \rightarrow \{\mathbb{0,
		1}\}.$$ We write $\tau \models \varphi$ for $\tau$ satisfies
		$\varphi$.
	\item An assignment $\tau$ satisfies a given formula $\varphi$ if and only
		if $[\varphi]^{\tau} = \mathbb{1}$.
		\item The set of all satisfying assignments of a formula
			$\varphi$ is denoted by
			$$\operatorname{Sat}(\varphi) := \{\tau; \tau \models
			\varphi\}.$$
	\item The satisfiablitiy problem (\textbf{SAT}): Given a Boolean formula
		$\varphi$, find whether there exists an assignment $\tau$ of
		$\varphi$ such that $\tau \models \varphi$. 
	\item Counting SAT Problem (\textbf{\#SAT}): Given a Boolean formula
		$\varphi$, compute the number of satisfying assignments of
		$\varphi$.
	\item A formula is in the negation normal form (\textbf{NNF}), if it
		contains only disjunctions and conjunctions of positive or
		negative literals.
	\item A formula is in the conjunctive normal form (\textbf{CNF}), if it
		is a conjunction of one or more clauses, where each clause is a
		disjunction of one or more literals.
	\item Given a formula $\varphi$ along with an assignment $\tau$ for
		$\varphi$. Let $V \subseteq \operatorname{Var} (\varphi)$ be a
		subset of variables. We define the partial assignment
		$\tau_{|V}$ as the restriction of $\tau$ to $V$, i.e.
		$$\tau_{|V}:V\rightarrow \{\mathbb{0}, \mathbb{1}\}:x\mapsto
		\tau(x)$$.
		
		For a formula $\varphi$ in CNF and a partial assignment
		$\tau_{|V}$, we say that $\tau_{|V}$ satisfies $\varphi$ if for
		each clause $C$ in $\varphi$, there is a literal $a \in C$ where
		$tau_{|V} \models a$.
	\item A Boolean formula $\varphi$ is in the decomposable negation normal
		form (\textbf{DNNF}) (we call it a decomposable formula), if it
		is in NNF and for each subformula of the form $\varphi' = \psi_1
		\land \psi_2$ we have $\operatorname{Var}(\psi_1) \cap
		\operatorname{Var}(\psi_2) = \emptyset$.
	\item A Boolean formula $\varphi$ is in the deterministic decomposable
		negation normal form (\textbf{d-DNNF}), if it is in DNNF and for
		each subformula of the form $\varphi' = \psi_1 \lor \psi_2$ we
		have $\operatorname{Sat}(\psi_1) \cap \operatorname{Sat}(\psi_2)
		= \emptyset$.
	\item A Bolean formula $\varphi$ is in the decision decomposable negation normal form
		(\textbf{dec-DNNF}) if it is in DNNF and each disjunction of the
		formula is of the form $\varphi' := (x \land \psi_1) \lor (\lnot
		x \land \psi_2)$ for some variable $x \in \operatorname{Var}
		(\varphi)$.
\end{itemize}
The last three definitions build the cornerstone of this report. The paper in
its essence inspects writing a given CNF-formula in either of the last two forms
in addition to the structuredness constraint, that is soon to be introduced and
proves upper- and lower-bounds of the sizes of the resulting formulas.


\subsection{Structured Formulas}
In this section we will introduce structured formulas. Structuredness is defined
over DNNF formulas. A structured formula admits an additional property that
makes it easier to follow dependencies between its subformulas and to design a
dynamic-programming solution for the \#SAT problem. This solution will be
exploited deeper in the fourth section of this report.

We define a vTree $T$ as a binary tree defined over a given formula $\varphi$,
such that there is a one-to-one correspondence between the leaves of the tree
and the variables of the formula $\operatorname{Var}(\varphi)$.  For a subtree
$H$ of $T$, let us call $V(H)$ the set of variables of $\varphi$ corresponding
to the leaves of $H$. Given a node $v$ in $T$, we denote the subtree rooted at
$v$ in $T$ by $T_v$.  We say that the formula $\varphi$ respects the vTree $T$,
if for each subformula $\varphi'$ of $\varphi$ of the form $\varphi' := \psi_1
\land \psi_2$, there is a node $v$ in the tree with two children $v_1, v_2$,
such that $\operatorname{Var}(\psi_1) \subseteq V(T_{v_1})$ and
$\operatorname{Var}(\psi_2) \subseteq V(T_{v_2})$.
A formula $\varphi$ is structured, if there is a vTree $T$ over $\varphi$ such
that $\varphi$ respects $T$. An example of structured formula and a
corresponding vTree can be seen in the figure below.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.2\linewidth]{../figures/vtree.eps}
	\caption{A vTree respected by the formula $(x\land(y\lor z)) \lor (z {
	\color{red}\land } \overline x)$. A conjunction and a corresponding node
are depicted in red.}%
	\label{fig:structed}
\end{figure}

\subsection{Hypergraphs and \texorpdfstring{$\beta$}{(beta)}-acyclic formulas}
Hypergraphs are a well-studied generalization of the concept of graphs. Similar
two an undirected graph, a hypergraph is defined as a set of vertices and edges,
where edges are subsets of the vertices. In contrast to typical graphs,
hypergrphs do not restrict the size of these subsets to two. Hence, each edge
can span no vertex, one vertex or arbitrary many vertices. Most definitions over
graphs such as paths, cycles and connectivity can be extended intuitively for
hypergraphs. However, cyclicity in hypergraphs can be interpreted in different
ways. Here we are interested in $\beta$-acyclic graphs. 

More formally, a hypergraph $G$ is a set of vertices $V$ and a family of subsets
over the vertices, we call them edges $E$. A walk in a hypergraph is a sequence
of alternating vertices and edges that starts and ends with edges, such that
each vertex is a common element for both edges preceding and following this
vertex $(e_1, x_1, \dots, x_n, e_{n+1})$. We call a walk that never visits the
same edge nor the same vertex twice a path. An example of a hyper graph is
depicted in the figure below. [todo]

In order to define $\beta$-acyclic graphs we need to define a
$\beta$-elimination of a graph. Let $\rho := v_1, \dots, v_n$ be an enumeration
of the vertices in the graph. We call $\rho$ a $\beta$-elimination, if for any
two edge $e_1, e_2 \in E$ and $v_i \in e_1 \cap e_2$, holds $e_{1|\geq i}
\subseteq e_2$ or $e_{2|\geq i} \subseteq e_1$, where $e_{\geq i} := \{v_j \in e:
j \geq i\}$. A hypergrph $G$ is $\beta$-acyclic if it admits a
$\beta$-elimination $\rho$.

The hypergraph of a CNF-formula is the hypergraph defined over its variables,
where each clause corresponds to an edge in the graph. More formally, given a
CNF-formula $\varphi$, let $\mathcal{C} := \{C_1, \dots C_m\}$ be the set of all
clauses in this formula. We define the hypergraph $G = (V, E)$ as the
hypergrpah of this formula, where $V := \operatorname{Var}(\varphi)$ and $E :=
\{\operatorname{Var}(C): C \in \mathcal{C}\}$. Note that the same edge might
correspond to multiple clauses with identical variable sets and different
(negated) literals. A Boolean formula $\varphi$ is $\beta$-acyclic if its
hypergraph is.


\subsection{Branch decomposition and MIM-width of a formula}
Back to typical graphs, we define a branch decomposition $T$ of a graph $G = (V,
E)$ as a binary rooted tree $T$, whose leaves are in one-to-one correspondence
with $V$. The maximal-induced-matching width (MIM-width) of a node $t$ in $T$ is
the size of the largest induced matching $M$ of $G[V\setminus V_t, V_t]$. As an
example see the figure below. [todo] The MIM-width of a branch decomposition $T$
$(\operatorname{mimw}(T))$ is the maximum MIM-width of its nodes
$$\operatorname{mimw}(T) = \max\{\operatorname{mimw}(t):t\in V(T)\}.$$ The
MIM-width of a graph $G$ is the minimum MIM-width of a branch decomposition of
this graph.

We define the incidence graph of a CNF-formula as the bipartite graph $G :=(A,
B, E)$, where $A$ is the set of variables of the formula, $B$ the set of the
clauses and a variable is adjacent to a clause if and only if there is a literal
in this clause that corresponds to this variable $$\{x, C\} \in E \iff x \in
\operatorname{Var}(C).$$ The MIM-width of a CNF-formula is the MIM-with of its
incidence graph.


\section{DPLL and solving \#SAT efficiently}

\section{Structured d-DNNF - Lower-bounds for the general approach}

\section{Conclusion}

\end{document}

